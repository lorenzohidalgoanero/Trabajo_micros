#include "ESTILO_PANTALLA.h"
// --- mapa de bits 8x8  ---
const uint8_t fuente[40][8] = {
   {0,0,0,0,0,0,0,0}, // 0: espacioo
   // A, B, C, D, E
   {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00},
   {0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00},
   {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00},
   {0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00},
   {0x7E,0x60,0x60,0x78,0x60,0x60,0x7E,0x00},
   // F, G, H, I, J
   {0x7E,0x60,0x60,0x78,0x60,0x60,0x60,0x00},
   {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00},
   {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00},
   {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},
   {0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00},
   // K, L (Arreglada), M, N, O
   {0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00},
   {0xF0,0x60,0x60,0x60,0x60,0x60,0xFE,0x00},
   {0xC6,0xEE,0xFE,0xD6,0xC6,0xC6,0xC6,0x00},
   {0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00},
   {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
   // P, Q, R, S, T
   {0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00},
   {0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00},
   {0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00},
   {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00},
   {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00},
   // U, V, W, X, Y, Z
   {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
   {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00},
   {0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0xC6,0x00},
   {0xC3,0x66,0x3C,0x18,0x3C,0x66,0xC3,0x00},
   {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00},
   {0xFE,0x06,0x0C,0x18,0x30,0x60,0xFE,0x00},
   // 0-9 (Indices 27-36)
   {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00},
   {0x18,0x18,0x38,0x18,0x18,0x18,0x7E,0x00},
   {0x3C,0x66,0x06,0x0C,0x30,0x60,0x7E,0x00},
   {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00},
   {0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x00},
   {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00},
   {0x3C,0x66,0x60,0x7C,0x66,0x66,0x3C,0x00},
   {0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x00},
   {0x3C,0x66,0x3C,0x66,0x66,0x66,0x3C,0x00},
   {0x3C,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00}
};
/*
Bits (0-7)       Hex
Fila 0: ...██...      0x18
Fila 1: ..████..      0x3C
Fila 2: .██..██.      0x66
Fila 3: .██..██.      0x66
Fila 4: .██████.      0x7E
Fila 5: .██..██.      0x66
Fila 6: .██..██.      0x66
Fila 7: ........      0x00 */
int getIndice(char c) {
   // función auxiliar: convierte minúsculas a mayúsculas automáticamente restando 32
   if (c >= 'a' && c <= 'z') {
       c -= 32;
   }
   if (c == ' ') return 0;
   if (c == ':' || c == '.') return 0; // Tratar puntos y dos puntos como espacio (o añadir símbolo)
   if (c >= 'A' && c <= 'Z') return c - 'A' + 1;
   if (c >= '0' && c <= '9') return c - '0' + 27;
   return 0; // Default espacio
}
Estilo_Pantalla::Estilo_Pantalla(Driver_Pantalla* tft, uint8_t escala)
   : _tft(tft), _escala(escala) {}
void Estilo_Pantalla::rellenarPantalla(uint16_t color) {
   _tft->rellenarPantalla(color);
}
void Estilo_Pantalla::setEscala(uint8_t nuevaEscala) {
   _escala = nuevaEscala;
}
// PARA ENTENDER ESTO:
/*la funcion dibujar letra se dedica simplemente a dibujar con pegotes de pixeles (bloques) los
* bits que el mapa de bits de la letra char que tenemos normalizada en esa megamatriz en la
* posicion y color que se le pasa por  parametros
*
* Este pegote de pixels lo ejecuta la funcion dibujar bloque del driver, que es el que trabaja
* físicamente con la OLED directamente
*
* */
void Estilo_Pantalla::dibujarLetraBase(int x, int y, char c, uint16_t color) {
   int idx = getIndice(c);
   const uint8_t* bitmap = fuente[idx];
   for (int fila = 0; fila < 8; fila++) {
       for (int col = 0; col < 8; col++) {
           if (bitmap[fila] & (1 << (7 - col))) {
               _tft->dibujarBloque(x + (col * _escala), y + (fila * _escala), color, _escala);
           }
       }
   }
}
// ESTA FUNCION ESCRIBIR se puede considerar la de ALTO NIVEL
/* Le pasamos directamente la posición y texto completo y datos del estilo 3D retro y se encarga
de llamar a las funciones que dibujan:
	A un nivel más bajo tenemos dibujar letras, que se encarga de situar una plantilla sobre el
	lienzo, una máscara de bits normalizado por letra, quien ordena al dibujar bloque (esa funcion
	que dibuja pegotes de pixeles sobre el lienzo) en funcion de los "1" de la mascara de bits.
	NOTA: esta funcion esta pensada para escribir una palabra en una altura Y, no un texto largo.
	Si es demasiado larga la frase se saldrá por la derecha de la pantalla.
	No hay una lógica pensada para continuar escribiendo debajo
*/
void Estilo_Pantalla::Escribir(int x, int y, const char* texto,
                              uint16_t colorFrente, uint16_t colorSombraDer, uint16_t colorSombraAbajo)
{
   int cursorX = x;
   int len = strlen(texto);
   for (int i = 0; i < len; i++) {
       char c = texto[i];
       // 1. SOMBRA ABAJO
       if (colorSombraAbajo != 0) // Pequeña optimización: no pintar si es negro/transparente
           dibujarLetraBase(cursorX, y + _escala, c, colorSombraAbajo);
       // 2. SOMBRA DERECHA
       if (colorSombraDer != 0)
           dibujarLetraBase(cursorX + _escala, y, c, colorSombraDer);
       // 3. FRENTE
       dibujarLetraBase(cursorX, y, c, colorFrente);
       cursorX += (9 * _escala); // espacios entre letras * la escala
   }
}
